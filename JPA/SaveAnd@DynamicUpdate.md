Referenced:
https://jojoldu.tistory.com/415
https://www.baeldung.com/spring-data-jpa-dynamicupdate
https://stackoverflow.com/questions/11881479/how-do-i-update-an-entity-using-spring-data-jpa


* JPA 교재



JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다.
em.update()와 같은 메서드는 없다.
이렇게 엔티티의 변경사항을 데이터베이스에서 자동으로 반영하는 기능을 변경 감지 (dirty checking) 이라고 한다.



    1.트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시(flush())가 호출됨.
    2. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾음.
    3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보냄.
    4. 쓰기 지연 저장소의 SQL을 데이터베이스에 보냄.
    5. 트랜잭션 커밋


    * 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용됨.
    * JPA의 기본전략은 엔티티의 모든 필드를 업데이트.
    * 필드가 많거나 내용이 너무 크면 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성하는 전략(DynamicUpdate)를 선택
    * @DynamicInsert (데이터를 저장할 때 데이터가 존재하는 필드만으로 INSERT SQL을 동적으로 생성) 도 있다.
    * 컬럼이 대략 30개 이상이 되면 기본방법인 정적 수정 쿼리보다 @DynamicUpdate를 사용한 동적 쿼리가 빠름
    * but, 한 테이블에 컬럼이 30개 이상 된다는 것은 테이블 설계상 책임이 적절하게 분리되지 않았을 가능성이 높음.




JPA Entity


When an application starts, Hibernate generates the SQL statements for CRUD operations of all the entities. These SQL statements are generated once and are cached, in memory, to improve the performance.

The generated SQL update statement includes all the columns of an entity. In case we update an entity, the values of the modified columns are passed to the SQL update statement. For the columns that are not updated, Hibernate uses their existing values for the update.


```
@Entity
public class Account {

    @Id
    private int id;

    @Column
    private String name;

    @Column
    private String type;

    @Column
    private boolean active;

    // Getters and Setters
}
```

```
// ExRepository
@Repository
public interface AccountRepository extends JpaRepository<Account, Integer> {
}

// update the name field of an Account object:

Account account = accountRepository.findOne(ACCOUNT_ID);
account.setName("Test Account");
accountRepository.save(account);

// After we execute this update, we can verify the generated SQL statement. The generated SQL statement will include all the columns of Account:

update Account set active=?, name=?, type=? where id=?
```


JPA @Entity with @DynamicUpdate


We've seen that even though we've modified the name field only, Hibernate has included all the columns in the SQL statement.


```@DynamicUpdateExample.java

@Entity
@DynamicUpdate
public class Account {
    // Existing data and methods
}

// Then, We can see that the SQL generated by Hibernate, in this case, includes only the name column:

update Account set name=? where id=?
```

Actually, when we use @DynamicUpdate on an entity, Hibernate does not use the cached SQL statement for the update. Instead, it will generate a SQL statement each time we update the entity. This generated SQL includes only the changed columns.


In order to find out the changed columns, Hibernate needs to track the state of the current entity. So, when we change any field of an entity, it compares the current and the modified states of the entity.


This means that @DynamicUpdate has a performance overhead associated with it. Therefore, we should only use it when it's actually required.



https://stackoverflow.com/questions/11881479/how-do-i-update-an-entity-using-spring-data-jpa



To update an entity by querying then saving is not efficient because it requires two queries and possibly the query can be quite expensive since it may join other tables and load any collections that have fetchType=FetchType.EAGER


Spring-data-jpa supports update operation.
You have to define the method in Repository interface.and annotated it with @Query and @Modifying.


```
@Modifying
@Query("update User u set u.firstname = ?1, u.lastname = ?2 where u.id = ?3")
void setUserInfoById(String firstname, String lastname, Integer userId);
// @Query is for defining custom query
// @Modifying is for telling spring-data-jpa that this query is an update operation and it requires executeUpdate() not executeQuery().
```

You can specify other return types:
int - the number of records being updated.
boolean - true if there is a record being updated. Otherwise, false.


The save method does work if you want to save the entity (It will delegate the call to either em.persist() or em.merge() behind the scene). Anyway, the custom query is useful when you want to update just some fields in database. 