A deprecated API is one that you are no longer recommended to use, due to changes in the API.


https://docs.oracle.com/javase/9/docs/api/java/lang/Boolean.html
```
// use
Boolean.valueOf(String)

// instead of
Boolean(String)
```


생성비용이 아주 비싼 객체가 반복해서 필요하다면 캐싱하여 재사용할것.

ex) String.matches 메서드를 사용하여 문자열 형태를 확인할 때, Pattern 인스턴스를 클래스 초기화(정적초기화) 과정에서 직접 생성해 캐싱해두고, 메서드가 호출될 때마다 이 인스턴스를 재사용하는게 성능을 끌어올릴 수 있따.

박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의.

ex) 변수를 long이 아닌 Long으로 선언해서 불필요한 Long인스턴스를 대량 생성하는 경우

하지만, 객체생성은 비싸니 피해야 한다로 오해하면 안된다. 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다.

데이터베이스 연결 같은 경우 생성비용이 비싸니 재사용하는 편이 낫지만, 일반적으로 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다. 요즘 JVM의 가비지 컬렉터는 상당히 잘 최적화 되어있어서 가벼운 객체용을 다룰 때는 직접 만든 객체 풀보다 훨씬 빠르다.

방어적 복자(defensive copy)가 필요한 상황에서 객체를 재사용했을 때의 피해가, 필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다. 방어적 복사에 실패하면 언제 터져 나올지 모르는 버그와 보안 구멍으로 이어지지만, 불필요한 객체 생성은 그저 코드의 형태와 성능에만 영향을 준다.